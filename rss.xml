<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ersami个人博客</title>
  
  
  <link href="https://www.ersblog.cn/rss.xml" rel="self"/>
  
  <link href="https://www.ersblog.cn/"/>
  <updated>2025-10-14T14:10:27.722Z</updated>
  <id>https://www.ersblog.cn/</id>
  
  <author>
    <name>Ersami</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker</title>
    <link href="https://www.ersblog.cn/posts/4126800539/"/>
    <id>https://www.ersblog.cn/posts/4126800539/</id>
    <published>2025-10-14T06:03:31.000Z</published>
    <updated>2025-10-14T14:10:27.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>我使用的虚拟机版本为Centos7。</p><h3 id="卸载旧版"><a href="#卸载旧版" class="headerlink" title="卸载旧版"></a>卸载旧版</h3><p>如果系统中存在旧版docker，先卸载旧版。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine \</span><br><span class="line">    docker-selinux </span><br></pre></td></tr></table></figure><h3 id="配置Docker的yum库"><a href="#配置Docker的yum库" class="headerlink" title="配置Docker的yum库"></a>配置Docker的yum库</h3><p>首先安装yum工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>安装成功后，配置Docker的yum源：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27;</span> /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure><p>更新yum，建立缓存</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum makecache fast</span><br></pre></td></tr></table></figure><h3 id="安装Docker-1"><a href="#安装Docker-1" class="headerlink" title="安装Docker"></a>安装Docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><p>检查Docker是否安装成功可以使用命令 <code>docker -v</code>,如果出现以下提示：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251014145345440.png" alt="image-20251014145345440"></p><p>则说明安装成功。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止Docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h3><p>官方镜像是在海外，速度较慢，建议替换为国内镜像。</p><p>我这里使用的是轩辕镜像，配置如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;: [</span></span><br><span class="line"><span class="string">        &quot;https://docker.xuanyuan.me&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="部署Mysql"><a href="#部署Mysql" class="headerlink" title="部署Mysql"></a>部署Mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>执行完命令以后，docker就会帮我们拉取并下载镜像，然后运行mysql容器。</p><h3 id="命令解读"><a href="#命令解读" class="headerlink" title="命令解读"></a>命令解读</h3><ul><li><p>docker run:创建并运行一个容器  -d是后台运行</p></li><li><p>–name:给容器命名，必须唯一</p></li><li><p>-p:端口映射  宿主机端口:容器中服务运行的端口</p></li></ul><p><strong>为什么要做端口映射？</strong></p><p>因为容器环境是对外隔离的，所以其他主机无法直接访问到容器中的服务（比如我现在有一台主机想要访问一台虚拟机中的容器是无法直接访问的，但是虚拟机是可以直接访问容器的），因此要通过端口映射，其他主机可以访问虚拟机的端口从而访问到容器中的端口。</p><ul><li><p>-e KEY=VALUE:配置环境变量</p></li><li><p>mysql :指定运行的镜像的名字</p></li></ul><h2 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p>这里有一张图可以帮助理解记忆一些常见命令：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251014155410000.png" alt="image-20251014155410000"></p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器（将容器中的进程停止，并不是删除容器）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看运行中的容器  （docker ps -a:查看所有容器）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p><strong>演示</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    605c77e624dd   16 months ago   141MB</span><br><span class="line">mysql        latest    3218b38490ce   17 months ago   516MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步，创建并允许Nginx容器</span></span><br><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5步，查看运行中容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第8步，查看所有容器</span></span><br><span class="line">docker ps -a --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第9步，再次启动nginx容器</span></span><br><span class="line">docker start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第10步，再次查看容器</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第12步，进入容器,查看容器内目录</span></span><br><span class="line"><span class="comment">#其中-it是用来创建一个可交互的终端</span></span><br><span class="line"><span class="comment">#bash是指定交互的方式（命令行还是其他）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it nginx bash   </span><br><span class="line"><span class="comment"># 或者，可以进入MySQL</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第13步，删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f nginx</span><br></pre></td></tr></table></figure><p><strong>命令别名</strong></p><p>给命令起别名可以简化复杂命令的书写，配置步骤如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> dis=<span class="string">&#x27;docker images&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">        . /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。因此，容器提供程序的运行环境，但是程序运行产生的数据、程序运行依赖的配置都应该与容器<strong>解耦</strong>。</p><h4 id="什么是数据卷？"><a href="#什么是数据卷？" class="headerlink" title="什么是数据卷？"></a>什么是数据卷？</h4><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的<strong>桥梁</strong>。</p><p>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p><p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251014175730813.png" alt="image-20251014175730813"></p><p>在上图中：</p><ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p><blockquote><p><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code>。</p></blockquote><p><strong>数据卷命令</strong></p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p><strong>注意：</strong>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><p>演示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line"><span class="comment">#-v 数据卷名称:容器内目录（不能为文件，否则报错）</span></span><br><span class="line">docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line"><span class="built_in">local</span>     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 497 12月 28 2021 50x.html</span><br><span class="line">-rw-r--r--. 1 root root 615 12月 28 2021 index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker <span class="built_in">exec</span> -it nginx bash</span><br></pre></td></tr></table></figure><p>如果我们在创建容器的时候不进行容器的挂载，那么系统也会为我们的容器创建匿名的数据卷并进行挂载。</p><p>查看一个容器数据卷挂载情况的流程如下：</p><ul><li><p>首先使用<code>docker inspect mysql</code>命令查看容器详细信息</p></li><li><p>然后找到如下部分：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/var/lib/mysql&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。</li><li>Source：宿主机目录</li><li>Destination : 容器内的目录</li></ul></li></ul><h4 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h4><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure><p><strong>演示</strong>:删除并重新创建mysql容器，并完成本地目录挂载：</p><ul><li>挂载<code>/root/mysql/data</code>到容器内的<code>/var/lib/mysql</code>目录</li><li>挂载<code>/root/mysql/init</code>到容器内的<code>/docker-entrypoint-initdb.d</code>目录（初始化的SQL脚本目录）</li><li>挂载<code>/root/mysql/conf</code>到容器内的<code>/etc/mysql/conf.d</code>目录（这个是MySQL配置文件目录）</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.删除原来的MySQL容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行新mysql容器，挂载本地目录</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /root/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v /root/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了</span></span><br><span class="line"><span class="built_in">ls</span> -l mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">总用量 4</span><br><span class="line">drwxr-xr-x. 2 root    root   20 5月  19 15:11 conf</span><br><span class="line">drwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 data</span><br><span class="line">drwxr-xr-x. 2 root    root   23 5月  19 15:11 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化</span></span><br><span class="line"><span class="built_in">ls</span> -l data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.查看MySQL容器内数据</span></span><br><span class="line"><span class="comment"># 5.1.进入MySQL</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123</span><br><span class="line"><span class="comment"># 5.2.查看编码表</span></span><br><span class="line">show variables like <span class="string">&quot;%char%&quot;</span>;</span><br><span class="line"><span class="comment"># 5.3.结果，发现编码是utf8mb4没有问题</span></span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line">| Variable_name            | Value                          |</span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line">| character_set_client     | utf8mb4                        |</span><br><span class="line">| character_set_connection | utf8mb4                        |</span><br><span class="line">| character_set_database   | utf8mb4                        |</span><br><span class="line">| character_set_filesystem | binary                         |</span><br><span class="line">| character_set_results    | utf8mb4                        |</span><br><span class="line">| character_set_server     | utf8mb4                        |</span><br><span class="line">| character_set_system     | utf8mb3                        |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql-8.0/charsets/ |</span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看数据</span></span><br><span class="line"><span class="comment"># 6.1.查看数据库</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="comment"># 结果，hmall是黑马商城数据库</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| hmall              |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment"># 6.2.切换到hmall数据库</span></span><br><span class="line">use hmall;</span><br><span class="line"><span class="comment"># 6.3.查看表</span></span><br><span class="line">show tables;</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_hmall |</span><br><span class="line">+-----------------+</span><br><span class="line">| address         |</span><br><span class="line">| cart            |</span><br><span class="line">| item            |</span><br><span class="line">| order           |</span><br><span class="line">| order_detail    |</span><br><span class="line">| order_logistics |</span><br><span class="line">| pay_order       |</span><br><span class="line">| user            |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="comment"># 6.4.查看address表数据</span></span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">| <span class="built_in">id</span> | user_id | province | city   | town     | mobile      | street        | contact   | is_default | notes |</span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">| 59 |       1 | 北京     | 北京   | 朝阳区    | 13900112222 | 金燕龙办公楼   | 李佳诚    | 0          | NULL  |</span><br><span class="line">| 60 |       1 | 北京     | 北京   | 朝阳区    | 13700221122 | 修正大厦       | 李佳红    | 0          | NULL  |</span><br><span class="line">| 61 |       1 | 上海     | 上海   | 浦东新区  | 13301212233 | 航头镇航头路   | 李佳星    | 1          | NULL  |</span><br><span class="line">| 63 |       1 | 广东     | 佛山   | 永春      | 13301212233 | 永春武馆       | 李晓龙    | 0          | NULL  |</span><br><span class="line">+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><h4 id="镜像的结构"><a href="#镜像的结构" class="headerlink" title="镜像的结构"></a>镜像的结构</h4><p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而<strong>不用重复制作</strong>。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251014195513360.png" alt="image-20251014195513360"></p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。<strong>我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</strong></p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong></p><p>常用命令如下：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>准备一个demo项目和对应的Dockerfile文件</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251014201847956.png" alt="image-20251014201847956"></p><p>首先，我们将<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251014201947980.png" alt="image-20251014201947980"></p><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录(但是一定要与Dockerfile中定好的一样)：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接指定Dockerfile目录</span></span><br><span class="line">docker build -t docker-demo:1.0 /root/demo</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251014202202382.png" alt="image-20251014202202382"></p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>容器之间能否互相访问呢？我们来测试一下。</p><p>首先，我们查看下nginx容器的详细信息，重点关注其中的网络IP地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect nginx</span><br><span class="line"><span class="comment">#网络信息如下</span></span><br><span class="line"> <span class="string">&quot;Networks&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;bridge&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;IPAMConfig&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Links&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Aliases&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;NetworkID&quot;</span>: <span class="string">&quot;b5684b121e5b225da9cc310c82be9cad6d766569d412b5def92285a6846d8a71&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;454baaff6edfc188458f40717f69abc47642e0d6876e4aed4d5082a8a52a526c&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.2&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPPrefixLen&quot;</span>: 16,</span><br><span class="line">                    <span class="string">&quot;IPv6Gateway&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6PrefixLen&quot;</span>: 0,</span><br><span class="line">                    <span class="string">&quot;DriverOpts&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;DNSNames&quot;</span>: null</span><br><span class="line">可以看到其ip为：172.17.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入docker-demo容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it docker-demo bash</span><br><span class="line"></span><br><span class="line">ping 172.17.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果如下</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 <span class="keyword">time</span>=0.463 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 <span class="keyword">time</span>=0.055 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 <span class="keyword">time</span>=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 <span class="keyword">time</span>=0.061 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 <span class="keyword">time</span>=0.061 ms</span><br></pre></td></tr></table></figure><p>发现可以互联，没有问题。</p><p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，<strong>而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</strong></p><p>所以，我们必须借助于docker的网络功能来解决这个问题。</p><p>常用命令如下：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><p>自定义网络演示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create ersami</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">b5684b121e5b   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">9516b045d2fd   ersami    bridge    <span class="built_in">local</span></span><br><span class="line">c966eef56748   host      host      <span class="built_in">local</span></span><br><span class="line">244e4a7c4401   none      null      <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中，除了ersami以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让docker-demo和nginx都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.nginx容器，指定别名为ng，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect ersami nginx --<span class="built_in">alias</span> ng</span><br><span class="line"><span class="comment"># 3.2.docker-demo容器，也就是我们的java项</span></span><br><span class="line">docker network connect ersami docker-demo --<span class="built_in">alias</span> <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入docker-demo容器，尝试利用别名访问ng</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it docker-demo bash</span><br><span class="line"><span class="comment"># 4.2.用ng别名访问</span></span><br><span class="line">ping ng</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING ng (172.20.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from nginx.ersami (172.20.0.2): icmp_seq=1 ttl=64 <span class="keyword">time</span>=0.093 ms</span><br><span class="line">64 bytes from nginx.ersami (172.20.0.2): icmp_seq=2 ttl=64 <span class="keyword">time</span>=0.066 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING nginx (172.20.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from nginx.ersami (172.20.0.2): icmp_seq=3 ttl=64 <span class="keyword">time</span>=0.050 ms</span><br><span class="line">64 bytes from nginx.ersami (172.20.0.2): icmp_seq=4 ttl=64 <span class="keyword">time</span>=0.062 ms</span><br></pre></td></tr></table></figure><p>OK，现在无需记住IP地址也可以实现容器互联了</p><p>我们也可以在创建容器的时候指定网络：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--network ersami</span><br><span class="line">docker run -d --name docker-demo -p 8080:8080 --network ersami docker-demo</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>在<strong>同一个自定义网络中</strong>的容器，可以通过别名互相访问 (不同网络中的容器是无法互相访问的)</li></ul><h3 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h3><p>大家可以看到，我们部署一个简单的java项目，其中包含3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了。</p><p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 <strong>docker-compose.yml</strong> 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>可以和手动部署对比着看：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251014220004587.png" alt="image-20251014220004587"></p><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><p>项目部署演示：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">  <span class="comment">#寻找当前目录下的Dockerfile文件构建镜像（由于没有指定镜像名，系统会默认命名为root-hmall）</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">      <span class="comment">#hmall依赖于mysql，所以mysql镜像会先安装（depends_on不写也没事，只会影响镜像安装顺序而已）</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="comment">#hm-net是网络标识，而hmall才是真正的网络名</span></span><br><span class="line">  <span class="attr">hm-net:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left"></td><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left"></td><td align="left">down</td><td align="left">停止并移除所有容器、网络</td></tr><tr><td align="left"></td><td align="left">ps</td><td align="left">列出所有启动的容器</td></tr><tr><td align="left"></td><td align="left">logs</td><td align="left">查看指定容器的日志</td></tr><tr><td align="left"></td><td align="left">stop</td><td align="left">停止容器</td></tr><tr><td align="left"></td><td align="left">start</td><td align="left">启动容器</td></tr><tr><td align="left"></td><td align="left">restart</td><td align="left">重启容器</td></tr><tr><td align="left"></td><td align="left">top</td><td align="left">查看运行中的进程</td></tr><tr><td align="left"></td><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td></tr></tbody></table><p>演示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除hmall镜像</span></span><br><span class="line">docker rmi hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动所有, -d 参数是后台启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network hmall    Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container hmall  Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE</span><br><span class="line">hmall               root-hmall          latest              32eebee16acd        362MB</span><br><span class="line">mysql               mysql               latest              3218b38490ce        516MB</span><br><span class="line">nginx               nginx               latest              605c77e624dd        141MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS</span><br><span class="line">hmall               root-hmall          <span class="string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp</span><br><span class="line">mysql               mysql               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp</span><br><span class="line">nginx               nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装Docker&quot;&gt;&lt;a href=&quot;#安装Docker&quot; class=&quot;headerlink&quot; title=&quot;安装Docker&quot;&gt;&lt;/a&gt;安装Docker&lt;/h2&gt;&lt;p&gt;我使用的虚拟机版本为Centos7。&lt;/p&gt;
&lt;h3 id=&quot;卸载旧版&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux常用指令</title>
    <link href="https://www.ersblog.cn/posts/1369438389/"/>
    <id>https://www.ersblog.cn/posts/1369438389/</id>
    <published>2025-10-13T12:38:37.000Z</published>
    <updated>2025-10-13T13:21:51.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>cd /</td><td>切换到根目录</td></tr><tr><td>cd ~</td><td>切换到用户主目录</td></tr><tr><td>cd ..</td><td>切换到上一层目录</td></tr><tr><td>cd -</td><td>切换到上一个操作所在的目录</td></tr><tr><td>ls</td><td>显示目录中的文件和子目录</td></tr><tr><td>ll</td><td>ls -l的别名，可以看到更加详细的信息</td></tr><tr><td>mkdir</td><td>创建新目录</td></tr><tr><td>find [路径] [表达式]</td><td>在指定目录及其子目录中搜索文件或目录，如:find /test -name ‘*.txt’就是查找/test目录下的所有txt文件</td></tr><tr><td>rmdir</td><td>删除空目录</td></tr><tr><td>rm</td><td>删除文件或目录</td></tr><tr><td>cp 源文件/目录  目标文件/目录</td><td>复制文件或目录 如：cp test.txt /root/test.txt 就是将当前目录下的test.txt文件复制到/root目录下并重命名为test.txt</td></tr><tr><td>mv 源文件/目录   目标文件/目录</td><td>移动文件或目录。与cp不同的是mv是文件”搬家“，个数并未增加</td></tr></tbody></table><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>mv、cp、rm等操作文件和目录都适用，在此就不重复列举。</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>touch</td><td>创建新文件或更新已存在文件</td></tr><tr><td>cat/more/less/tail</td><td>查看文件</td></tr><tr><td>vim</td><td>修改文件的内容（也可以创建文件，但是要记得保存）输入 <code>wq</code> 代表写入内容并退出，即保存；输入 <code>q!</code>代表强制退出不保存</td></tr></tbody></table><h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>tar -zcvf  打包压缩后的文件名  要打包压缩的文件</td><td>打包并压缩文件。其中z:调用gzip压缩命令进行压缩；c：打包文件；v：显示运行过程；f：指定文件名。假如 test 目录下有三个文件分别是：<code>aaa.txt</code>、 <code>bbb.txt</code>、<code>ccc.txt</code>，如果我们要打包 <code>test</code> 目录并指定压缩后的压缩包名称为 <code>test.tar.gz</code> 可以使用命令：<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code></td></tr><tr><td>tar -xvf 压缩文件</td><td>解压缩。其中x代表解压。将 <code>/test</code> 下的 <code>test.tar.gz</code> 解压到当前目录下可以使用命令：<code>tar -xvf test.tar.gz</code>。将 /test 下的 test.tar.gz 解压到根目录/usr 下:<code>tar -xvf test.tar.gz -C /usr</code>（<code>-C</code> 代表指定解压的位置）</td></tr></tbody></table><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>操作系统中每个文件都拥有<strong>特定的权限、所属用户和所属组</strong>。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为**读(readable)、写(writable)和执行(executable)<strong>，分为三组。分别对应文件的</strong>属主(owner)，属组(group)和其他用户(other)**，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251013210814239.png" alt="image-20251013210814239"></p><p>第一列的内容的信息解释如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20251013210829951.png" alt="image-20251013210829951"></p><p><strong>文件类型：</strong></p><ul><li>d：代表目录</li><li>-：代表文件</li><li>l：代表软链接（可以认为是 window 中的快捷方式）</li></ul><p><strong>Linux 中权限分为以下几种：</strong></p><ul><li>r：代表权限是可读，r 也可以用数字 4 表示</li><li>w：代表权限是可写，w 也可以用数字 2 表示</li><li>x：代表权限是可执行，x 也可以用数字 1 表示</li></ul><p><strong>文件和目录权限的区别：</strong></p><p>对文件和目录而言，读写执行表示不同的意义。</p><p>对于文件：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以使用 cat 查看文件的内容</td></tr><tr><td align="left">w</td><td align="right">可以修改文件的内容</td></tr><tr><td align="left">x</td><td align="right">可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以查看目录下列表</td></tr><tr><td align="left">w</td><td align="right">可以创建和删除目录下文件</td></tr><tr><td align="left">x</td><td align="right">可以使用 cd 进入目录</td></tr></tbody></table><p>需要注意的是：<strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p><p><strong>在 Linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p><ul><li><strong>所有者(u)</strong> ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用 chown 用户名 文件名来修改文件的所有者 。</li><li><strong>文件所在组(g)</strong> ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</li><li><strong>其它组(o)</strong> ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li></ul><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>chmod</td><td>修改文件/目录的权限。例如：chmod u=rwx,g=rw,o=r test.txt 或者chmod 764 test.txt</td></tr></tbody></table><h2 id="系统状态"><a href="#系统状态" class="headerlink" title="系统状态"></a>系统状态</h2><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>free</td><td>用于查看系统的内存使用情况。</td></tr><tr><td>ps</td><td>用于查看系统中的进程信息，包括进程的 ID、状态、资源使用情况等。<code>ps -ef</code>/<code>ps -aux</code>：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：`ps -ef</td></tr><tr><td>systemctl [命令] [服务名称]</td><td>用于管理系统的服务和单元，可以查看系统服务的状态、启动、停止、重启等。</td></tr></tbody></table><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>ping</td><td>测试与目标主机的网络连接</td></tr><tr><td>ifconfig/ip</td><td>用于查看系统的网络接口信息，包括网络接口的IP地址、MAC地址、状态等。</td></tr><tr><td>netstat</td><td>用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等。</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>sudo + 其他指令</td><td>以系统管理者的身份执行指令</td></tr><tr><td>grep [选项] “搜索内容” 文件路径</td><td>非常强大且常用的文本搜索命令，它可以根据指定的字符串或正则表达式，在文件或命令输出中进行<strong>匹配查找</strong>，适用于<strong>日志分析、文本过滤、快速定位</strong>等多种场景。示例：忽略大小写搜索 syslog 中所有包含 error 的行：<code>grep -i &quot;error&quot; /var/log/syslog</code>，查找所有与 java 相关的进程：`ps -ef</td></tr><tr><td>kill -9 进程的pid</td><td>杀死进程（-9 表示强制终止）先用 ps 查找进程，然后用 kill 杀掉。</td></tr><tr><td>shutdown</td><td><code>shutdown -h now</code>：指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</td></tr><tr><td>reboot</td><td><code>reboot</code>：重开机。<code>reboot -w</code>：做个重开机的模拟（只有纪录并不会真的重开机）。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录操作&quot;&gt;&lt;a href=&quot;#目录操作&quot; class=&quot;headerlink&quot; title=&quot;目录操作&quot;&gt;&lt;/a&gt;目录操作&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbod</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://www.ersblog.cn/posts/1723864827/"/>
    <id>https://www.ersblog.cn/posts/1723864827/</id>
    <published>2025-09-07T06:41:51.000Z</published>
    <updated>2025-09-07T06:56:50.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象一定是在堆中创建的吗？"><a href="#对象一定是在堆中创建的吗？" class="headerlink" title="对象一定是在堆中创建的吗？"></a>对象一定是在堆中创建的吗？</h2><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250902214557872.png" alt="image-20250902214557872"></p><h3 id="逃逸"><a href="#逃逸" class="headerlink" title="逃逸"></a>逃逸</h3><p>在方法中创建对象之后，如果这个对象除了在方法体中还在其它地方被引用了，此时如果方法执行完毕，由于该对象有被引用，所以 GC 有可能是无法立即回收的，此时便成为 <strong>内存逃逸现象</strong>。</p><p><strong>逃逸状态：</strong></p><p>一个对象有三种逃逸状态：</p><ol><li><p><strong>全局逃逸</strong>（GlobalEscape）：即一个对象的作用范围逃出了当前方法或者当前线程，</p><blockquote><p>一般有以下几种场景：<br>① 对象是一个静态变量<br>② 对象是一个已经发生逃逸的对象<br>③ 对象作为当前方法的返回值</p></blockquote></li><li><p><strong>参数逃逸</strong>（ArgEscape）：即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。</p></li><li><p><strong>没有逃逸</strong>：即方法中的对象没有发生逃逸。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object globalVariableObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instanceObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">globalVariableEscape</span><span class="params">()</span>&#123;</span><br><span class="line">        globalVariableObject = <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">// 静态变量，外部线程可见，发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceObjectEscape</span><span class="params">()</span>&#123;</span><br><span class="line">        instanceObject = <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">// 赋值给堆中实例字段，外部线程可见，发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">returnObjectEscape</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();   <span class="comment">// 返回实例，外部线程可见，发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">noEscape</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">noEscape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();   <span class="comment">// 仅创建线程可见，对象无逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p>标量可以理解成一种不可分解的变量，如java内部的基本数据类型、引用类型等。 与之对应的聚合量是可以被拆解的，如对象。</p><p>当通过逃逸分析一个对象只会作用于方法内部，虚拟机可以通过使用标量替换来进行优化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">noEscape</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">26</span>, <span class="string">&quot;TomCoding noEscape&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> person.name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>比如上述noEscape()方法中person对象只会在方法内部，通过标量替换技术得到如下伪码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">noEscape</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;TomCoding noEscape&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以看到运行上面伪码之后，将不再从堆中分配内存创建Person对象，而是将成员变量分解作为栈帧中的局部变量。这样随着方法调用结束，栈帧也会销毁。有效的减少了堆中创建对象及gc次数</strong></p><h3 id="逃逸分析的优势"><a href="#逃逸分析的优势" class="headerlink" title="逃逸分析的优势"></a>逃逸分析的优势</h3><ul><li><h4 id="同步消除（锁消除）"><a href="#同步消除（锁消除）" class="headerlink" title="同步消除（锁消除）"></a>同步消除（锁消除）</h4></li></ul><p>因为同步锁是非常消耗性能的，所以当编译器确定一个对象没有发生逃逸时，它便会移除该对象的同步锁。</p><ul><li><h4 id="标量替换-1"><a href="#标量替换-1" class="headerlink" title="标量替换"></a>标量替换</h4></li></ul><p>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。</p><ul><li><h4 id="栈内存分配"><a href="#栈内存分配" class="headerlink" title="栈内存分配"></a>栈内存分配</h4></li></ul><p>栈内存分配很好理解，在上文中提过，就是将原本分配在堆内存上的对象转而分配在栈内存上，这样就可以减少堆内存的占用，从而减少 GC 的频次。</p><h2 id="什么是程序计数器？"><a href="#什么是程序计数器？" class="headerlink" title="什么是程序计数器？"></a>什么是程序计数器？</h2><p>程序计数器是每个线程私有的（线程安全的），每个线程一份，内部保存的字节码的行号，用于记录正在执行的字节码指令的地址。</p><h2 id="详细介绍Java堆"><a href="#详细介绍Java堆" class="headerlink" title="详细介绍Java堆"></a>详细介绍Java堆</h2><p>堆是<strong>线程共享的区域</strong>（线程不安全的）：主要用来保存对象实例，数组等，内存不够则抛出OOM（内存溢出）异常。</p><p>java8及之后堆的组成是<strong>年轻代 + 老年代</strong>。</p><ul><li>年轻代被划为三部分，Eden区和两个大小严格相同的Survivor区（幸存者区）</li><li>老年代主要保存生命周期长的对象，一般是一些老的对象</li></ul><blockquote><p>根据JVM的策略，在经过几次垃圾收集后，任然存活于幸存者区的对象将被移动到老年代区</p></blockquote><p>JDK1.7和JDK1.8的区别</p><ul><li>1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码</li><li>1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出</li></ul><p>以下为JVM内存结构图：</p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906163132979.png" style="zoom:150%;" /><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="什么是虚拟机栈？"><a href="#什么是虚拟机栈？" class="headerlink" title="什么是虚拟机栈？"></a>什么是虚拟机栈？</h3><ul><li><p>每个线程运行时所需要的内存（线程安全的），称为虚拟机栈，先进后出</p></li><li><p>每个栈由多个栈帧（frame）组成，对应每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈，对应着当前正在执行的那个方法</p><blockquote><p>例如，此时线程调用方法一，那么此时活动栈就是栈一，接着在方法一中调用了方法二，此时栈二压栈，活动栈就变成了栈二</p></blockquote></li></ul><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906165004278.png" alt="image-20250906165004278"></p><h3 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h3><p>垃圾回收的对象主要指堆内存，而栈内存在栈帧弹出以后就会释放。</p><h3 id="栈内存分配的越打越好吗？"><a href="#栈内存分配的越打越好吗？" class="headerlink" title="栈内存分配的越打越好吗？"></a>栈内存分配的越打越好吗？</h3><p>并不是。默认的栈内存为1024k(1m)，栈内存过大会导致线程数变少。例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半。</p><h3 id="方法内的局部变量是否线程安全？"><a href="#方法内的局部变量是否线程安全？" class="headerlink" title="方法内的局部变量是否线程安全？"></a>方法内的局部变量是否线程安全？</h3><ul><li>如果方法内局部变量没有逃离方法的作用范围，他是线程安全的</li><li>如果局部变量引用了对象，并逃离方法的作用范围，则需要考虑线程安全</li></ul><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906165622884.png" alt="image-20250906165622884"></p><h3 id="什么情况可能会导致栈内存溢出？"><a href="#什么情况可能会导致栈内存溢出？" class="headerlink" title="什么情况可能会导致栈内存溢出？"></a>什么情况可能会导致栈内存溢出？</h3><ul><li>栈帧过多：例如递归调用</li></ul><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906165807896.png" alt="image-20250906165807896"></p><ul><li>栈帧过大</li></ul><h3 id="堆栈的区别是什么？"><a href="#堆栈的区别是什么？" class="headerlink" title="堆栈的区别是什么？"></a>堆栈的区别是什么？</h3><ul><li><p>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的。堆会GC垃圾回收，而栈不会。</p></li><li><p>栈内存是线程私有的，而堆内存是线程共有的</p></li><li><p>两者异常错误不同：</p><p>栈空间不足：StackOverFlowError</p><p>堆空间不足：OutOfMemoryError</p></li></ul><h2 id="介绍一下方法区（元空间）"><a href="#介绍一下方法区（元空间）" class="headerlink" title="介绍一下方法区（元空间）"></a>介绍一下方法区（元空间）</h2><ul><li>方法区是各个线程<strong>共享的内存区域</strong></li><li>主要存储类的信息、运行时常量池</li><li>虚拟机启动的时候创建，关闭虚拟机时释放</li><li>如果方法区中的内存无法满足分配需求，则会抛出OutOfMemoryError: Metaspace,有时也会提醒你方法区空间太小。</li></ul><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906171531789.png" alt="image-20250906171531789"></p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906171603118.png" alt="image-20250906171603118"></p><h2 id="介绍一下运行时常量池"><a href="#介绍一下运行时常量池" class="headerlink" title="介绍一下运行时常量池"></a>介绍一下运行时常量池</h2><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的<strong>类名、方法名、参数类型、字面量等</strong>信息。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906171832087.png" alt="image-20250906171832087"></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>常量池是<code>*.class</code>文件中的，当该类被加载，它的常量信息就会被<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong>。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906172030502.png" alt="image-20250906172030502"></p><h2 id="你听过直接内存吗？"><a href="#你听过直接内存吗？" class="headerlink" title="你听过直接内存吗？"></a>你听过直接内存吗？</h2><p>Java文件拷贝</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906173235417.png" alt="image-20250906173235417"></p><p>常规IO的数据拷贝流程</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906173316257.png" alt="image-20250906173316257"></p><p>由于Java无法直接读取系统缓存区的数据，所以要先将数据拷贝一份到java缓冲区中，正是因为这种不必要的拷贝操作导致常规IO执行效率低。</p><p>NIO数据拷贝流程</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906173544379.png" alt="image-20250906173544379"></p><p>Java可以直接读取直接内存，执行效率大大提高。</p><p><strong>总结：</strong></p><ul><li>直接内存并不属于JVM中的内存结构，不由JVM进行管理，是虚拟机的系统内存。（也就是操作系统内存）</li><li>常见于NIO操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受JVM内存回收管理</li></ul><h2 id="什么是类加载器、双亲委派机制？"><a href="#什么是类加载器、双亲委派机制？" class="headerlink" title="什么是类加载器、双亲委派机制？"></a>什么是类加载器、双亲委派机制？</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906180740358.png" alt="image-20250906180740358"></p><p>JVM只会运行二进制文件，类加载器的作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。</p><h3 id="类加载器种类"><a href="#类加载器种类" class="headerlink" title="类加载器种类"></a>类加载器种类</h3><p>启动类加载器（加载对应目录下的类）、扩展类加载器（加载对应目录下的类）、应用类加载器（加载用户自己编写的Java类）、自定义加载器。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906181057344.png" alt="image-20250906181057344"></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906181417521.png" alt="image-20250906181417521"></p><p>例如现在有一个用户编写的Student类，先在<code>AppClassLoader</code>加载，发现有上一级就先委托给上级类加载器加载，然后<code>ExtClassLoader</code>发现有上一级，就继续向上委派给<code>BootStrapClassLoder</code>，此时已经到顶开始正式加载，此时<code>BootStrapClassLoder</code>无法加载，<code>ExtClassLoader</code>开始尝试加载，发现也无法加载，最终回到<code>AppClassLoader</code>加载。</p><h3 id="JVM为什么采用双亲委派机制？"><a href="#JVM为什么采用双亲委派机制？" class="headerlink" title="JVM为什么采用双亲委派机制？"></a>JVM为什么采用双亲委派机制？</h3><ul><li>通过双亲委派机制可以避免同一个类被反复加载，当父类已经加载后则无需重复加载，保证唯一性。</li><li>为了安全，保证类库API不会被修改</li></ul><p>​    例如：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906182116927.png" alt="image-20250906182116927"></p><p>此时执行main函数会报错，在<code>java.lang.String</code>中找不到main方法。</p><p>由于双亲委派机制，<code>java.lang.String</code>在启动类加载器得到加载，但在核心<code>jre</code>库中有其相同名字的类文件，但该类中并没有<code>main</code>方法。这样就能防止恶意篡改核心API库。</p><h2 id="类装载的执行过程（重要）"><a href="#类装载的执行过程（重要）" class="headerlink" title="类装载的执行过程（重要）"></a>类装载的执行过程（重要）</h2><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906183637999.png" alt="image-20250906183637999"></p><p>类装载过程分为以上7个阶段，其中验证、准备和解析这三个部分统称为链接(linking)。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>通过类的全名，获取类的二进制数据流</li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型） （<strong>其实就是将类的信息存入到方法区）</strong></li><li>创建<code>java.lang.Class</code>类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li></ul><p>​        <img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906184303141.png" alt="image-20250906184303141"></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证类是否符合JVM规范，安全性检查。</p><ul><li><p>文件格式验证</p></li><li><p>元数据验证</p></li><li><p>字节码验证</p><p>以上这三点都是格式检查，例如：文件格式是否错误、语法是否错误、字节码是否错误。</p></li><li><p>符号引用验证——Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法，检查他们是否存在</p></li></ul><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906184754566.png" alt="image-20250906184754566"></p><p>上图“=”后面的就是所说的字符串。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为<strong>类变量</strong>（静态变量）分配内存并设置类变量初始值。</p><ul><li>static变量，分配空间在准备阶段完成（设置默认值），赋值在初始阶段完成</li><li>static变量是final的基本类型以及字符串常量，值已确定，赋值在准备阶段完成</li><li>static变量是final的引用类型，那么赋值也会在初始化阶段完成</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>把类中的符号引用转换为<strong>直接引用</strong>。</p><p>例如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906195432931.png" alt="image-20250906195432931"></p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250906195448269.png" alt="image-20250906195448269"></p><p>“#1”、“#2”等就可以看作是符号引用，而通过符号引用找到的<code>java/io/PrintStream</code>、<code>println</code>就是直接引用。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>对类的<strong>静态变量、静态代码块</strong>执行初始化操作。</p><ul><li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类</li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行</li></ul><blockquote><p>注意：子类访问父类静态变量，只触发父类初始化</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>JVM开始从入口方法开始执行用户的程序代码</p><ul><li>调用静态类成员信息（比如：静态字段、静态方法）</li><li>使用new关键字为其创建对象实例</li></ul><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。</p><p><strong>总结</strong></p><ul><li>加载：查找和导入class文件</li><li>验证：保证加载类的准确性</li><li>准备：为类变量分配内存并设置类变量初始值</li><li>解析：把类中的符号引用转换为直接引用</li><li>初始化：对类的静态变量、静态代码块执行初始化操作</li><li>使用：JVM开始从入口方法开始执行用户的程序代码</li><li>卸载：当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象</li></ul><h2 id="对象什么时候可以被垃圾回收？"><a href="#对象什么时候可以被垃圾回收？" class="headerlink" title="对象什么时候可以被垃圾回收？"></a>对象什么时候可以被垃圾回收？</h2><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收。</p><p>定位垃圾的方式有两种：</p><ul><li><p>引用计数法（对象间循环引用会导致内存泄漏）</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907115115427.png" alt="image-20250907115115427"></p></li><li><p><strong>可达性分析算法</strong></p></li></ul><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907115228756.png" alt="image-20250907115228756"></p><p>​    扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到就表示可以回收。（上图中的X,Y两个节点是可以回收的）</p><h3 id="哪些对象可以作为GC-Root"><a href="#哪些对象可以作为GC-Root" class="headerlink" title="哪些对象可以作为GC Root?"></a>哪些对象可以作为GC Root?</h3><ul><li><p>虚拟机栈中引用的对象</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907115613415.png" alt="image-20250907115613415"></p></li><li><p>方法区中类静态属性引用的对象</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907115623467.png" alt="image-20250907115623467"></p></li><li><p>方法区中常量引用的对象</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907115636949.png" alt="image-20250907115636949"></p></li><li><p>本地方法中JNI（即Native方法）引用的对象</p></li></ul><h2 id="JVM垃圾回收算法有哪些？"><a href="#JVM垃圾回收算法有哪些？" class="headerlink" title="JVM垃圾回收算法有哪些？"></a>JVM垃圾回收算法有哪些？</h2><ul><li><p>标记清除算法：垃圾回收分为两个阶段，分别是标记和清除，效率高，有磁盘碎片，内存不连续。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907120826906.png" alt="image-20250907120826906"></p></li><li><p>标记整理算法：和标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，无碎片，对象需要移动，效率低。（一般老年代使用）</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907120843688.png" alt="image-20250907120843688"></p></li><li><p>复制算法：将原有的内存空间一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾回收。无碎片，内存使用率低。（一般年轻代使用）</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907120854516.png" alt="image-20250907120854516"></p></li></ul><h2 id="说一下JVM中的分代回收"><a href="#说一下JVM中的分代回收" class="headerlink" title="说一下JVM中的分代回收"></a>说一下JVM中的分代回收</h2><p>一、堆的区域划分</p><ul><li><p>堆被分为了两份：新生代和老年代【1：2】</p></li><li><p>对于新生代，内部又被分为了三个区域，Eden，幸存者区survivor（分成from和to）【8：1：1】</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907122715517.png" alt="image-20250907122715517"></p></li></ul><p>二、对象回收分代回收策略</p><ul><li>新创建的对象都会先分配到Eden区</li><li>当Eden区内存不足，标记Eden与from的存活对象</li><li>将存活对象采用复制算法复制到to中，复制完毕后，Eden和from内存都得到释放</li><li>经过一段时间后Eden的内存又出现不足，标记Eden区和to区存活对象，将其复制到from区</li><li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存者区内存不足或者大对象会提前晋升）</li></ul><h2 id="MinorGC、MixedGC、FullGC的区别是什么？"><a href="#MinorGC、MixedGC、FullGC的区别是什么？" class="headerlink" title="MinorGC、MixedGC、FullGC的区别是什么？"></a>MinorGC、MixedGC、FullGC的区别是什么？</h2><ul><li>MinorGC（youngGC）发生在新生代的垃圾回收、暂停时间（STW）短</li><li>MixedGC:新生代 + 老年代部分区域的垃圾回收，G1收集器持有</li><li>FullGC：新生代 + 老年代完整垃圾回收，暂停时间（STW）长，应尽力避免</li></ul><blockquote><p>STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收完成</p></blockquote><h2 id="说一下JVM有哪些垃圾回收器？"><a href="#说一下JVM有哪些垃圾回收器？" class="headerlink" title="说一下JVM有哪些垃圾回收器？"></a>说一下JVM有哪些垃圾回收器？</h2><ul><li><p>串行垃圾收集器：Serial GC、Serial Old GC</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907125233051.png" alt="image-20250907125233051"></p></li><li><p>并行垃圾收集器：Parallel Old GC、ParNew GC（JDK8默认使用此垃圾回收器）</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907125250649.png" alt="image-20250907125250649"></p></li><li><p>CMS(并发)垃圾收集器：CMS GC，作用在老年代</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250907125305748.png" alt="image-20250907125305748"></p></li><li><p>G1垃圾收集器，作用在新生代和老年代（JDK9之后默认使用G1）</p></li></ul><h2 id="详细聊一下G1垃圾回收器"><a href="#详细聊一下G1垃圾回收器" class="headerlink" title="详细聊一下G1垃圾回收器"></a>详细聊一下G1垃圾回收器</h2><ul><li>应用于新生代和老年代，在JDK9之后默认使用</li><li>划分为多个区域，每个区域都可以充当Eden、Survivor、old、humongous，其中humongous专为大对象准备</li><li>采用复制算法</li><li>响应时间与吞吐量兼顾</li><li>分成三个阶段：新生代回收（stw）、并发标记（重新标记要stw）、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象的速度）会触发Full GC</li></ul><h2 id="Java内存泄漏的排查思路"><a href="#Java内存泄漏的排查思路" class="headerlink" title="Java内存泄漏的排查思路"></a>Java内存泄漏的排查思路</h2><p>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况</p><ul><li>通过jmap或设置jvm参数获取堆内存快照dump</li><li>通过工具VisualVM去分析dump分析，VisualVM可以加载离弦的dump文件</li><li>通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</li><li>找到对应的代码，通过阅读上下文的情况，进行修复即可</li></ul>]]></content>
    
    
    <summary type="html">JVM面经</summary>
    
    
    
    <category term="面试" scheme="https://www.ersblog.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java函数式编程</title>
    <link href="https://www.ersblog.cn/posts/2003235859/"/>
    <id>https://www.ersblog.cn/posts/2003235859/</id>
    <published>2025-09-05T08:11:54.000Z</published>
    <updated>2025-10-13T13:25:13.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>Lambda表达式由3个部分组成：<strong>参数部分、-&gt;、逻辑部分</strong>。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712204043986.png" alt="image-20250712204043986"></p><p><strong>整个Lambda表达式就是一个函数对象。</strong></p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712204847531.png" alt="image-20250712204847531"></p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712205832503.png" alt="image-20250712205832503"></p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="类名-静态方法"><a href="#类名-静态方法" class="headerlink" title="类名::静态方法"></a>类名::静态方法</h4><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712223911302.png" alt="image-20250712223911302"></p><h4 id="类名-非静态方法"><a href="#类名-非静态方法" class="headerlink" title="类名::非静态方法"></a>类名::非静态方法</h4><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712224448120.png" alt="image-20250712224448120"></p><h4 id="对象-非静态方法"><a href="#对象-非静态方法" class="headerlink" title="对象::非静态方法"></a>对象::非静态方法</h4><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712224752062.png" alt="image-20250712224752062"></p><h4 id="类名-new"><a href="#类名-new" class="headerlink" title="类名::new"></a>类名::new</h4><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712225842420.png" alt="image-20250712225842420"></p><p>以上<code>Student::new</code>虽然长相一样，但是可以通过类型来区分。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712230130847.png" alt="image-20250712230130847"></p><h4 id="this-非静态方法（3的特例，只能在类内部使用）"><a href="#this-非静态方法（3的特例，只能在类内部使用）" class="headerlink" title="this::非静态方法（3的特例，只能在类内部使用）"></a>this::非静态方法（3的特例，只能在类内部使用）</h4><h4 id="super-非静态方法-3的特例，只能在类内部使用"><a href="#super-非静态方法-3的特例，只能在类内部使用" class="headerlink" title="super::非静态方法(3的特例，只能在类内部使用)"></a>super::非静态方法(3的特例，只能在类内部使用)</h4><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>如果两个函数对象满足以下要求，那么就可以将他们归为一类，抽象为一个函数式接口。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712210704891.png" alt="image-20250712210704891"></p><p>在接口上方打上<code>@FunctionalInterface</code>注解以便在编译阶段检查接口是否满足条件有且仅有一个抽象方法。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712210822402.png" alt="image-20250712210822402"></p><h3 id="常见函数接口"><a href="#常见函数接口" class="headerlink" title="常见函数接口"></a>常见函数接口</h3><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712214146174.png" alt="image-20250712214146174"></p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712214302842.png" alt="image-20250712214302842"></p><p><strong>！！！特例</strong></p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250712231224254.png" alt="image-20250712231224254"></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>形如<code>(int y) -&gt; x + y</code>与它的外部变量形成了闭包。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250713155556593.png" alt="image-20250713155556593"></p><p><strong>！！！注意</strong>：变量x必须要是final或者effective final(虽然没有定义为final，但是后文并没有x进行过修改)。但是对象内部的值是可以修改的。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250713155829817.png" alt="image-20250713155829817"></p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250713155831959.png" alt="image-20250713155831959"></p><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>让接受多个参数的函数转换成一系列只接受一个参数的函数的过程叫做柯里化。</p><p>例子如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250713161533968.png" alt="image-20250713161533968"></p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250713161200812.png" alt="image-20250713161200812"></p><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><h3 id="！！！特性"><a href="#！！！特性" class="headerlink" title="！！！特性"></a>！！！特性</h3><p>一次使用</p><p>两类操作（中间操作 lazy 懒惰,终结操作 eager 迫切）</p><p>一次使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line">stream.forEach(System.out::println); <span class="comment">//报错,因为流中数据已经被消费完了，无法被再次消费</span></span><br></pre></td></tr></table></figure><p>两类操作</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250717001618569.png" alt="image-20250717001618569"></p><h3 id="过滤filter"><a href="#过滤filter" class="headerlink" title="过滤filter"></a>过滤filter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    Stream.of(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;marry&quot;</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">15</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">            ).filter(stu -&gt; stu.getAge() &lt;= <span class="number">18</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250714211045960.png" alt="image-20250714211045960"></p><h3 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    Stream.of(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;marry&quot;</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">15</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">            ).map(stu -&gt; stu.getName() + <span class="string">&quot;xixi&quot;</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250714211025319.png" alt="image-20250714211025319"></p><h3 id="降维（扁平化映射）flatMap"><a href="#降维（扁平化映射）flatMap" class="headerlink" title="降维（扁平化映射）flatMap"></a>降维（扁平化映射）flatMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(</span><br><span class="line">                        List.of(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;marry&quot;</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">15</span>, <span class="string">&quot;男&quot;</span>)),</span><br><span class="line">                        List.of(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;black&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;sam&quot;</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;sim&quot;</span>, <span class="number">15</span>, <span class="string">&quot;男&quot;</span>))</span><br><span class="line">                )</span><br><span class="line">                .flatMap(list -&gt; list.stream())</span><br><span class="line">                .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250714211438621.png" alt="image-20250714211438621"></p><p>将外部的list的去除，得到list里面的数据。</p><h3 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h3><p>用已有数据构建出Stream对象。</p><p>方式有以下三种：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250714211651254.png" alt="image-20250714211651254"></p><p>集合构建流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//集合构建(Collection及其子类)</span></span><br><span class="line">      List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).stream();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//map特殊处理</span></span><br><span class="line">      Map.of(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>).entrySet().stream();</span><br></pre></td></tr></table></figure><p>数组构建流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组构建</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.stream(array);</span><br></pre></td></tr></table></figure><p>对象构建流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(</span><br><span class="line">                        List.of(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;marry&quot;</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">15</span>, <span class="string">&quot;男&quot;</span>)),</span><br><span class="line">                        List.of(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;black&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;sam&quot;</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;sim&quot;</span>, <span class="number">15</span>, <span class="string">&quot;男&quot;</span>))</span><br><span class="line">                )</span><br></pre></td></tr></table></figure><h3 id="流的合并concat"><a href="#流的合并concat" class="headerlink" title="流的合并concat"></a>流的合并concat</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream1 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line">Stream&lt;Integer&gt; concat = Stream.concat(stream1, stream2);</span><br><span class="line">concat.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><p>skip(long n) 跳过n个，保留剩余部分。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">concat.skip(<span class="number">2</span>).forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>limit(long n) 保留前n个数据，剩余的舍弃。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">concat.limit(<span class="number">2</span>).forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>takeWhile(Predicate p) 条件成立保留，一旦条件不成立，剩下的不要。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">concat.takeWhile(x -&gt; x &lt; <span class="number">3</span>).forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>dropWhile(Predicate p) 条件成立舍弃，一旦条件不成立，剩下的保留。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">concat.dropWhile(x-&gt;x &gt;= <span class="number">3</span>).forEach(System.out::print);</span><br></pre></td></tr></table></figure><h3 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h3><p>不用现有数据生成Stream对象。</p><p>方式有以下三种：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250714222751669.png" alt="image-20250714222751669"></p><p>IntStream.range(start,end)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>,<span class="number">10</span>).forEach(System.out::print); <span class="comment">//左闭右开</span></span><br><span class="line">IntStream.rangeClosed(<span class="number">1</span>,<span class="number">10</span>).forEach(System.out::print);<span class="comment">//闭区间</span></span><br></pre></td></tr></table></figure><p>IntStream.iterate(初始值,生成式) 或者IntStream.iterate(初始值,判断条件,生成式)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).limit(<span class="number">5</span>).forEach(System.out::print);</span><br><span class="line">IntStream.iterate(<span class="number">1</span>, x -&gt; x &lt;= <span class="number">9</span> ,x -&gt; x + <span class="number">2</span>).forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>IntStream.generate()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.generate(() -&gt; ThreadLocalRandom.current().nextInt(<span class="number">100</span>)).limit(<span class="number">5</span>).forEach(System.out::println);<span class="comment">//生成100以内的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数生成的另一种方法      ThreadLocalRandom.current().ints(流的大小,下限,上限)</span></span><br><span class="line">ThreadLocalRandom.current().ints(<span class="number">5</span>,<span class="number">0</span>,<span class="number">100</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>findFirst()  找到第一个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .filter(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        .findFirst()   <span class="comment">//返回的是Optional对象</span></span><br><span class="line">        .orElse(-<span class="number">1</span>));  <span class="comment">//不存在则返回-1</span></span><br><span class="line"></span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .filter(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        .findFirst()</span><br><span class="line">        .ifPresent(System.out::println);  <span class="comment">//如果存在则打印</span></span><br></pre></td></tr></table></figure><p>findAny() 找到任意一个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">.filter(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">.findAny()</span><br><span class="line">.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>anyMatch()  只要有任意一个符合，则返回true</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .anyMatch(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>allMatch() 全部符合才返回true</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .allMatch(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>noneMatch() 都不符合才返回true</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .noneMatch(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>distinct()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>)</span><br><span class="line">        .distinct()</span><br><span class="line">        .forEach(System.out::print);</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>sorted()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      Stream.of(<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">              .sorted((a,b) -&gt; a &lt; b ? -<span class="number">1</span> : a == b ? <span class="number">0</span> : <span class="number">1</span>)  <span class="comment">//升序排序，返回-1说明a比b小，a排在前，否则b在前</span></span><br><span class="line">              .forEach(System.out::print);</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后的代码</span></span><br><span class="line">      Stream.of(<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">              .sorted(Comparator.comparingInt(a -&gt; a))</span><br><span class="line">              .forEach(System.out::print);</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序排序</span></span><br><span class="line">      Stream.of(<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">              .sorted(Comparator.comparingInt(a -&gt; (<span class="type">int</span>) a).reversed())</span><br><span class="line">              .forEach(System.out::print);</span><br></pre></td></tr></table></figure><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250716220500929.png" alt="image-20250716220500929"></p><p>以strength降序排序，在strength相同时以名字升序排序。</p><h3 id="化简-reduce"><a href="#化简-reduce" class="headerlink" title="化简 reduce"></a>化简 reduce</h3><p>两两合并</p><p><code>.reduce((p,x)-&gt;r)</code>、<code>.reduce(init,(p,x)-&gt;r)</code> 其中p为上次的合并结果，x为当前元素，r为本次合并结果,init为初始值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">90</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">89</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;刘子&quot;</span>, <span class="number">78</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;八爷&quot;</span>, <span class="number">69</span>)</span><br><span class="line">).reduce((h1, h2) -&gt; h1.strength &gt; h2.strength ? h1 : h2));  <span class="comment">//返回值为optional</span></span><br><span class="line"></span><br><span class="line">System.out.println(Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">90</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">89</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;刘子&quot;</span>, <span class="number">78</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;八爷&quot;</span>, <span class="number">69</span>)</span><br><span class="line">).reduce(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;-&quot;</span>,-<span class="number">1</span>),(h1, h2) -&gt; h1.strength &gt; h2.strength ? h1 : h2)); <span class="comment">//返回值为Hero，如果流中没有数据，则默认返回Hero(&quot;-&quot;,-1)</span></span><br></pre></td></tr></table></figure><p>底层为reduce的一些方法，求最值、平均数、数量等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">90</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">89</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;刘子&quot;</span>, <span class="number">78</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;八爷&quot;</span>, <span class="number">69</span>)</span><br><span class="line">).count());  </span><br><span class="line"></span><br><span class="line">System.out.println(Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">90</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">89</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;刘子&quot;</span>, <span class="number">78</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;八爷&quot;</span>, <span class="number">69</span>)</span><br><span class="line">).max(Comparator.comparingInt(Hero::strength)));</span><br></pre></td></tr></table></figure><h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;张胜男&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;刘子&quot;</span>,<span class="string">&quot;八爷&quot;</span>)</span><br><span class="line">        .collect(Collectors.toList())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream.of(<span class="string">&quot;张胜男&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;刘子&quot;</span>,<span class="string">&quot;八爷&quot;</span>)</span><br><span class="line">        .collect(Collectors.toSet())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream.of(<span class="string">&quot;张胜男&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;刘子&quot;</span>, <span class="string">&quot;八爷&quot;</span>)</span><br><span class="line">        .collect(Collectors.toMap(name -&gt; name, name -&gt; <span class="number">1</span>))</span><br><span class="line">        .forEach((key,value) -&gt; System.out.println(key + <span class="string">&quot;:&quot;</span> + value));</span><br></pre></td></tr></table></figure><p>实际应用中Collectors.toMap基本很少用，常用的是Collectors.groupingBy()来做分组需求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//以名字长度作为分组条件，长度相同的为一组</span></span><br><span class="line">Stream.of(<span class="string">&quot;张胜男&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;刘子&quot;</span>, <span class="string">&quot;八爷&quot;</span>)</span><br><span class="line">        .collect(Collectors.groupingBy(String::length,Collectors.toList()))</span><br><span class="line">        .forEach((key,value) -&gt; System.out.println(key+<span class="string">&quot;:&quot;</span>+value));</span><br></pre></td></tr></table></figure><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250716230340923.png" alt="image-20250716230340923"></p><p>下游收集器（配合Collectors.groupingBy()使用）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       </span><br><span class="line"><span class="comment">//Collectors.mapping：做转换，将hero对象转换为需要的数据，然后收集到list集合中</span></span><br><span class="line">Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;张胜男&quot;</span>, <span class="number">90</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">89</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;刘子&quot;</span>, <span class="number">78</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;八爷&quot;</span>, <span class="number">69</span>)</span><br><span class="line">                ).collect(Collectors.groupingBy(h -&gt; h.name.length(), Collectors.mapping(h -&gt; h.strength, Collectors.toList())))</span><br><span class="line">                .forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="comment">//按名字长度分组，但是要将名字拆分为一个个字符</span></span><br><span class="line"><span class="comment">//.chars():将字符串中的每个字符所对应的ASCII码值放到整数流中</span></span><br><span class="line">Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;张胜男&quot;</span>, <span class="number">90</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">89</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;刘子&quot;</span>, <span class="number">78</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;八爷&quot;</span>, <span class="number">69</span>)</span><br><span class="line">                ).collect(Collectors.groupingBy(h -&gt; h.name.length(), Collectors.flatMapping(h -&gt; h.name.chars().mapToObj(Character::toString),Collectors.toList())))</span><br><span class="line">                .forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value));</span><br></pre></td></tr></table></figure><p>结果如下：<img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250716234036295.png" alt="image-20250716234036295"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按名字长度分组，求每组包含多少个元素</span></span><br><span class="line">Stream.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;张胜男&quot;</span>, <span class="number">90</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">89</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;刘子&quot;</span>, <span class="number">78</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;八爷&quot;</span>, <span class="number">69</span>)</span><br><span class="line">        ).collect(Collectors.groupingBy(h -&gt; h.name.length(), Collectors.counting()))</span><br><span class="line">        .forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按名字长度分组，求每组strength的和        </span></span><br><span class="line">Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;张胜男&quot;</span>, <span class="number">90</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">89</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;刘子&quot;</span>, <span class="number">78</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;八爷&quot;</span>, <span class="number">69</span>)</span><br><span class="line">                ).collect(Collectors.groupingBy(h -&gt; h.name.length(), Collectors.mapping(h -&gt; h.strength,Collectors.reducing(<span class="number">0</span>,(p,x) -&gt; p + x))))</span><br><span class="line">                .forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value));</span><br></pre></td></tr></table></figure><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250717000232926.png" alt="image-20250717000232926"></p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250717000241502.png" alt="image-20250717000241502"></p><h3 id="基本流"><a href="#基本流" class="headerlink" title="基本流"></a>基本流</h3><p><code>IntStream</code> 、<code>LongStream</code> 、<code>DoubleStream</code> 。</p>]]></content>
    
    
    <summary type="html">函数式编程</summary>
    
    
    
    <category term="技术" scheme="https://www.ersblog.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="https://www.ersblog.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot单机项目部署</title>
    <link href="https://www.ersblog.cn/posts/2184816291/"/>
    <id>https://www.ersblog.cn/posts/2184816291/</id>
    <published>2025-09-05T07:59:45.000Z</published>
    <updated>2025-10-13T13:25:57.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a><strong>服务器初始化</strong></h2><p>首先购买服务器，这里我们选用宝塔 Linux 应用的轻量应用服务器</p><p>购买好服务器后，进入控制台，可以看到新增的服务器信息，注意不要主动对外暴露公网 IP！</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224131011.png" alt="image-20250418224131011"></p><p>点击服务器进入详情页，在防火墙标签页中放通 8888 宝塔面板端口，否则无法在自己的电脑上访问宝塔。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224227477.png" alt="image-20250418224227477"></p><p>首次登录时，需要先登录服务器，通过输入命令的方式获取宝塔默认账号密码，如图：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224309730.png" alt="image-20250418224309730"></p><p>点击登录后，进入到 web 终端，复制脚本并执行：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224327539.png" alt="image-20250418224327539"></p><p>根据终端输出的信息，访问宝塔面板，输入初始用户名和密码：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224539551.png" alt="image-20250418224539551"></p><p>首次进入宝塔时，会提示我们安装环境，这里推荐安装 LNMP（包含 Nginx 服务器），适合部署前后端分离的项目：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224600896.png" alt="image-20250418224600896"></p><p>首次进入宝塔面板时，记得修改面板账号密码（每次修改完都要重新登录）：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224615777.png" alt="image-20250418224615777"></p><h2 id="部署规划"><a href="#部署规划" class="headerlink" title="部署规划"></a>部署规划</h2><p>做好规划后，我们需要在腾讯云控制台的防火墙中开通需要外网访问的服务端口，比如 MySQL 和 Redis：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224425698.png" alt="image-20250418224425698"></p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>宝塔面板已经自动安装 MySQL 数据库，我们可以直接使用。</p><p>先为后端项目添加一个数据库。数据库名称和我们项目需要的数据库名称保持一致（此处为 mianshiya），注意用户名、密码和访问权限：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224900949.png" alt="image-20250418224900949"></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>在宝塔面板的软件商店中，搜索并安装 Redis：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418224959584.png" alt="image-20250418224959584"></p><p>安装完成后，需要配置 Redis，开启远程访问并配置密码，否则我们自己的电脑是无法连接 Redis 的：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225018521.png" alt="image-20250418225018521"></p><p>修改配置后，一定要重载配置才能生效：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225033739.png" alt="image-20250418225033739"></p><h3 id="Java-环境"><a href="#Java-环境" class="headerlink" title="Java 环境"></a>Java 环境</h3><p>要部署 Java 项目，必须安装 JDK。在宝塔面板中，可以通过下图的方式快速安装指定版本的 JDK。此处我们先安装 JDK 17：</p><h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3><p>比如 <a href="https://console.cloud.tencent.com/cos/bucket">腾讯云 COS 对象存储</a>、<a href="https://click.aliyun.com/m/1000400408/">阿里云百炼 AI</a>，可以去对应的官网开通。</p><p>如果不会开通的话，可以通过第 4 章教程开通 COS 对象存储，第 9 章教程开通阿里云百炼 AI。</p><p>注意，要给对象存储增加该服务器 IP（或者实际访问前端域名）的跨域配置，否则编辑图片时将无法正确加载图片。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225106154.png" alt="image-20250418225106154"></p><h2 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h2><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改 <code>application-prod</code> 生产环境配置，包括数据库、Redis、对象存储、阿里云百炼 AI 的 key 等，替换为上述安装依赖时指定的配置（如用户名、密码）。</p><p>注意为了性能，还要关闭 MyBatis Plus 的日志；为了安全，要给 Knife4j 接口文档设置用户名和密码。</p><p>参考配置如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线上配置文件</span></span><br><span class="line"><span class="comment"># @author &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"># @from &lt;a href=&quot;https://codefather.cn&quot;&gt;编程导航&lt;/a&gt;</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8123</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 数据库配置</span></span><br><span class="line">  <span class="comment"># todo 需替换配置</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://81.69.229.63:3306/yu_picture</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">yu_picture_root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yu_picture_123456</span></span><br><span class="line">  <span class="comment"># Redis 配置</span></span><br><span class="line">  <span class="comment"># todo 需替换配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">81.69</span><span class="number">.229</span><span class="number">.63</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 生产环境关闭日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 接口文档配置</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">basic:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="comment"># 对象存储配置</span></span><br><span class="line"><span class="attr">cos:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">secretId:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">region:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">bucket:</span> <span class="string">xxx</span></span><br><span class="line"><span class="comment"># 阿里云 AI 配置</span></span><br><span class="line"><span class="attr">aliYunAi:</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="string">xxx</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h3><p>首先更改 pom.xml 文件的打包配置，删除掉主类配置的 <code>skip</code> 配置，才能打包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.yupi.yupicturebackend.YuPictureBackendApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 IDEA 中打开后端项目，忽略测试并打包：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225233488.png" alt="image-20250418225233488"></p><p>上传 jar 包到服务器，此处为了方便，就放到 web 根目录：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225254088.png" alt="image-20250418225254088"></p><p>然后添加 Java 项目，<strong>在项目执行命令中，必须指定生产环境的配置！</strong>还可以根据需要调整内存：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225307545.png" alt="image-20250418225307545"></p><p>但是，我们现在无法通过浏览器访问接口文档,这是因为我们的服务器防火墙没有放开 8123 端口。<strong>这里我们故意不放开</strong>，因为在之前的部署规划中，后端需要通过 Nginx 进行转发，从而解决跨域问题。</p><h3 id="Nginx-转发"><a href="#Nginx-转发" class="headerlink" title="Nginx 转发"></a>Nginx 转发</h3><p>新建一个 Nginx 站点，域名填写当前服务器 IP 或者自己的域名，根目录随意填写即可（只要不包含中文）：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225407376.png" alt="image-20250418225407376"></p><p>如果访问的是后端接口（地址有 <code>/api</code> 前缀），则 Nginx 将请求转发到后端服务，对应配置代码如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /api &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span>  http://127.0.0.1:8123;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Host <span class="variable">$proxy_host</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">  <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，对于本项目，光有 HTTP 转发配置还不够！后端还需要提供 WebSocket 连接，所以也要对 WebSocket 进行转发，再给 Nginx 补充下列配置：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代理 WebSocket 连接 (专门用于 WebSocket 请求)</span></span><br><span class="line"><span class="section">location</span> /api/ws &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://127.0.0.1:8123;</span><br><span class="line">  <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">  <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</span><br><span class="line">  <span class="attribute">proxy_read_timeout</span> <span class="number">86400s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改完后，就可以通过 80 端口（可以省略）访问到接口了。</p><p><strong>一定要注释掉下列配置！</strong>否则访问接口文档时，静态资源的加载可能会出错。因为浏览器会从本地缓存加载资源，而不是动态请求资源。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225518467.png" alt="image-20250418225518467"></p><h2 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h2><h3 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h3><p>线上的前端需要请求线上的后端接口，所以需要修改 <code>request.ts</code> 文件中的请求地址为线上：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区分开发和生产环境</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEV_BASE_URL</span> = <span class="string">&quot;http://localhost:8123&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PROD_BASE_URL</span> = <span class="string">&quot;http://81.69.229.63&quot;</span>;</span><br><span class="line"><span class="comment">// 创建 Axios 实例</span></span><br><span class="line"><span class="keyword">const</span> myAxios = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="variable constant_">PROD_BASE_URL</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，由于本项目用到了 WebSocket，还要同步修改 <code>pictureEditWebSocket.ts</code> 文件中的 WebSocket 的连接地址：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEV_BASE_URL</span> = <span class="string">&quot;ws://localhost:8123&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PROD_BASE_URL</span> = <span class="string">&quot;ws://81.69.229.63&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;PROD_BASE_URL&#125;</span>/api/ws/picture/edit?pictureId=<span class="subst">$&#123;<span class="variable language_">this</span>.pictureId&#125;</span>`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="打包部署-1"><a href="#打包部署-1" class="headerlink" title="打包部署"></a>打包部署</h3><p>1）参考 Vite 官网，在 <code>package.json</code> 文件中定义 <code>pure-build</code> 命令：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pure-build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;run-p type-check \&quot;build-only &#123;@&#125;\&quot; --&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）执行 <code>pure-build</code> 命令，执行打包构建。</p><p>注意，如果 Node.js 版本较低，会构建失败，这时可以到 <a href="https://nodejs.org/zh-cn">官网</a> 安装更新的版本，比如 v20.17.0 等长期支持版本。</p><p>构建成功后，可以得到用于部署的静态文件 <code>dist</code> 目录：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225712573.png" alt="image-20250418225712573"></p><p>把 dist 目录下的所有文件上传到服务器上（可以新建一个 yu-picture-frontend 目录）。文件较多时，建议先在本地压缩，上传压缩包到服务器后再解压。如图：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225724888.png" alt="image-20250418225724888"></p><h3 id="Nginx-转发-1"><a href="#Nginx-转发-1" class="headerlink" title="Nginx 转发"></a>Nginx 转发</h3><p>一般来说，用户无法直接访问服务器上的文件，需要使用 Nginx 提供静态文件的访问能力。</p><p>修改已有站点的网站目录配置，指向前端文件根目录：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250418225740880.png" alt="image-20250418225740880"></p><p>然后访问服务器地址（或者自己配置的域名），就能打开前端网站了.</p><p>但是经过验证，目前访问除了主页外的其他页面（比如 /add_picture），如果刷新页面，就会出现 404 错误。</p><p>这个问题是由于 Vue 是单页面应用（前端路由），打包后的文件只有 <code>index.html</code>，服务器上不存在对应的页面文件（比如 /add_picture.html），所以需要在 Nginx 配置转发。如果找不到某个页面文件，就加载主页 index.html 文件。</p><p>修改 Nginx 配置，补充下列代码：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">  <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html /index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2>]]></content>
    
    
    <summary type="html">单机项目部署教程</summary>
    
    
    
    <category term="技术" scheme="https://www.ersblog.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="https://www.ersblog.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>博客添加域名</title>
    <link href="https://www.ersblog.cn/posts/b3c9dd23/"/>
    <id>https://www.ersblog.cn/posts/b3c9dd23/</id>
    <published>2025-09-03T12:45:46.000Z</published>
    <updated>2025-10-13T13:26:37.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>我这里使用的是腾讯云。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>配置时，只需要将 DNS 配置里面的 A 记录指向这 4 个 IP 地址中的至少一个</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>配置后的状态如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903205427722.png" alt="image-20250903205427722"></p><p>其中CNAME那一行的配置是必须的，不然后面github上操作时DNS解析会出问题。</p><h2 id="GithubPages操作"><a href="#GithubPages操作" class="headerlink" title="GithubPages操作"></a>GithubPages操作</h2><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com//img/image-20250903205848541.png" alt="image-20250903205848541"></p><p>在Custom domain下的框框里填上自己刚刚购买的域名，点击Save即可。设置成功后上方会有绿色的提示已发布成功。（github支持自定义域名的 HTTPS 请求，如需配置，可勾选下方的 <code>Enforce HTTPS</code>）。</p>]]></content>
    
    
    <summary type="html">博客添加域名教程</summary>
    
    
    
    <category term="技术" scheme="https://www.ersblog.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="https://www.ersblog.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Butterfly搭建个人博客网站(二、Butterfly美化网站)</title>
    <link href="https://www.ersblog.cn/posts/7a891ac2/"/>
    <id>https://www.ersblog.cn/posts/7a891ac2/</id>
    <published>2025-09-03T09:42:41.000Z</published>
    <updated>2025-10-13T13:55:32.179Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们利用Hexo搭建了一个网站的框架雏形，接下来我们结合Butterfly来对我们的网站进行美化。</p><h2 id="什么是Butterfly？"><a href="#什么是Butterfly？" class="headerlink" title="什么是Butterfly？"></a>什么是Butterfly？</h2><p><strong>Butterfly：轻量级、高效的Web开发框架</strong></p><p>是一个由Python构建的微型Web框架，专注于提供简单、优雅且高效的Web应用解决方案。它以其简洁的API设计和灵活的可扩展性赢得了开发者们的青睐。</p><p>Butterfly的核心理念是“少即是多”，即通过最小化代码量实现最大化的功能。它借鉴了其他知名框架如Flask和Django的优点，并在它们的基础上进行了创新。Butterfly的设计目标是让开发者能够快速地搭建和部署Web应用程序，同时保持代码的高度可读性和维护性。</p><h2 id="安装Butterfly主题"><a href="#安装Butterfly主题" class="headerlink" title="安装Butterfly主题"></a>安装Butterfly主题</h2><h3 id="在hexo项目根目录下下载主题。"><a href="#在hexo项目根目录下下载主题。" class="headerlink" title="在hexo项目根目录下下载主题。"></a>在<code>hexo</code>项目根目录下下载主题。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><h3 id="安装pug-和-stylus-渲染器。"><a href="#安装pug-和-stylus-渲染器。" class="headerlink" title="安装pug 和 stylus 渲染器。"></a>安装<code>pug</code> 和 <code>stylus</code> 渲染器。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="修改项目根目录下的-config-yml文件（称为站点配置文件），开启主题。"><a href="#修改项目根目录下的-config-yml文件（称为站点配置文件），开启主题。" class="headerlink" title="修改项目根目录下的_config.yml文件（称为站点配置文件），开启主题。"></a>修改项目根目录下的<code>_config.yml</code>文件（称为站点配置文件），开启主题。</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p><strong>！注意：</strong></p><p>为了減少升级主题带来的不便，我们可以把主题文件夹中(即themes文件夹)的 <code>_config.yml</code> 重命名为 <code>_config.butterfly.yml</code>，复制到 Hexo 根目录下与_config.yml同级。</p><p>Hexo会自动合并主题中的<code>_config.yml</code>和 <code>_config.butterfly.yml</code> ，如果存在同名配置，会使用<code>_config.butterfly.yml</code>的配置，其优先度较高。所以像和博客网址相关联的固定资料可以设置在<code>_config.yml</code>中，比如博客的标题、作者信息和邮箱等等资料，而和主题样式相关的配置放在 <code>_config.butterfly.yml</code> 中，那么在将来你想换一个主题是很方便的。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="搜索插件"><a href="#搜索插件" class="headerlink" title="搜索插件"></a>搜索插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>更改配置文件 <code>_config.butterfly.yml：</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use: local_search</span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">  # Local Search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search for Posts</span><br><span class="line">    hits_empty: &quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot; # 如果没有查到内容相关内容显示</span><br></pre></td></tr></table></figure><p>效果：给网站增加一个搜索栏</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903180333999.png" alt="image-20250903180333999"></p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903180339824.png" alt="image-20250903180339824"></p><h3 id="图片懒加载插件"><a href="#图片懒加载插件" class="headerlink" title="图片懒加载插件"></a>图片懒加载插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中添加以下配置（注意是系统设置文件不是主题设置文件）：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lazyload:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">loadingImg:</span> <span class="string">/img/loading.gif</span></span><br></pre></td></tr></table></figure><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903180631723.png" alt="image-20250903180631723"></p><p>效果:当图片资源加载时用设置的动态加载图片覆盖图片异常显示</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903180458900.png" alt="image-20250903180458900"></p><h3 id="字数统计插件"><a href="#字数统计插件" class="headerlink" title="字数统计插件"></a>字数统计插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save or yarn add hexo-wordcount</span><br></pre></td></tr></table></figure><p>在 <code>_config.butterfly.yml</code> 中修改以下配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903180809582.png" alt="image-20250903180809582"></p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903180812883.png" alt="image-20250903180812883"></p><h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><h3 id="修改顶部菜单"><a href="#修改顶部菜单" class="headerlink" title="修改顶部菜单"></a>修改顶部菜单</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">博文</span> <span class="string">||</span> <span class="attr">fa fa-graduation-cap:</span></span><br><span class="line">    <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">生活</span> <span class="string">||</span> <span class="attr">fas fa-list:</span></span><br><span class="line">    <span class="string">分享:</span> <span class="string">/shuoshuo/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-comments-o</span></span><br><span class="line">    <span class="string">相册:</span> <span class="string">/photos/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-camera-retro</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">影视:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">  <span class="comment"># 友链: /links/ || fa fa-link</span></span><br><span class="line">  <span class="string">留言板:</span> <span class="string">/comment/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-paper-plane</span></span><br><span class="line">  <span class="comment">#留言板: /messageboard/ || fa fa-paper-plane</span></span><br><span class="line">  <span class="string">关于笔者:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span>  </span><br></pre></td></tr></table></figure><blockquote><p>必须是 <code>/xxx/</code>，后面<code>||</code>分开，然后写图标名，如果不想显示图标，图标名可不写</p></blockquote><p>注意这里只是创建了导航菜单的·标签，我们还要新建对应的标签页：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>文件位置：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903181326849.png" alt="image-20250903181326849"></p><p>打开对应文件夹下的index.md,加上对应的type：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903181422087.png" alt="image-20250903181422087"></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2025-09-03 13:09:06</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure><p>最终效果如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903181504129.png" alt="image-20250903181504129"></p><h3 id="修改个人信息"><a href="#修改个人信息" class="headerlink" title="修改个人信息"></a>修改个人信息</h3><p>修改配置文件 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Ersami个人博客</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span><span class="comment">#副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">记录生活</span><span class="comment">#个性签名</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Ersami</span><span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span><span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span>    <span class="comment">#中国的时区</span></span><br></pre></td></tr></table></figure><h3 id="修改侧边栏"><a href="#修改侧边栏" class="headerlink" title="修改侧边栏"></a>修改侧边栏</h3><p>修改配置文件 <code>_config.butterfly.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Show the button to hide the aside in bottom right button</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Position: left / right</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br></pre></td></tr></table></figure><p>添加个人链接：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Social media links</span></span><br><span class="line"><span class="comment"># Formal:</span></span><br><span class="line"><span class="comment">#   icon: link || the description || color</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fab fa-github:</span> <span class="string">https://github.com/megumieren</span> <span class="string">||</span> <span class="string">Github</span> <span class="string">||</span> <span class="string">&#x27;#24292e&#x27;</span></span><br><span class="line">  <span class="attr">fab fa-bilibili:</span> <span class="string">https://space.bilibili.com/2127161957</span> <span class="string">||</span> <span class="string">Bilibili</span> <span class="string">||</span> <span class="string">&#x27;#ffc0cb&#x27;</span></span><br><span class="line">  <span class="attr">fab fa-qq:</span> <span class="string">tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2381087337&amp;website=www.oicqzone.com</span> <span class="string">||</span> <span class="string">QQ</span></span><br></pre></td></tr></table></figure><p>在<code>aside</code>里的<code>card_author</code>更改个人信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># icon: fab fa-github</span></span><br><span class="line">      <span class="comment"># text: Follow Me</span></span><br><span class="line">      <span class="comment"># link: https://github.com/megumieren</span></span><br></pre></td></tr></table></figure><blockquote><p>fa-github是框架自带的图标库，<code>Butterfly</code>支持<a href="https://fontawesome.com/icons?from=io">font-awesome v6</a>图标，当然你也可以根据自身需求进行定制。</p></blockquote><p>效果如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903182627516.png" alt="image-20250903182627516"></p><h3 id="图片设置"><a href="#图片设置" class="headerlink" title="图片设置"></a>图片设置</h3><p>图片放在在<code>/themes/butterfly/source/img文件夹下面就行</code></p><p>打开配置文件 <code>_config.butterfly.yml</code></p><p>网站图标</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span> <span class="string">/img/favicon.png</span></span><br></pre></td></tr></table></figure><p>头像</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/profile_picture.png</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>背景</p><p>背景建议是将封面图index_img:不设置，直接设置background: /img/背景图2.jpg，然后将顶部图像设置为透明default_top_img: rgba(0, 0, 0, 0)，将footer_img设置为transparent这样的效果可以让你的背景图保持简洁（”一图流“）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Website Background</span></span><br><span class="line"><span class="comment"># Can set it to color or image url</span></span><br><span class="line"><span class="attr">background:</span> <span class="string">/img/bg.png</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">rgba(0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">)</span></span><br><span class="line"><span class="comment"># The background image of footer</span></span><br><span class="line"><span class="attr">footer_img:</span> <span class="string">transparent</span></span><br></pre></td></tr></table></figure><p>文章封面图</p><p>打开<code>source/_posts/xxx.md</code>文章：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">XXXXX</span>        <span class="comment"># 标题</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">XXXXX</span>         <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">XXXXX</span>   <span class="comment"># 分类</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">XXXXX</span>  <span class="comment"># 描述</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">XXXXX</span>      <span class="comment"># 顶部背景图</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">XXXXX</span>        <span class="comment"># 文章封面</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="代码块样式"><a href="#代码块样式" class="headerlink" title="代码块样式"></a>代码块样式</h3><p>打开配置文件 <code>_config.butterfly.yml：</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">mac</span>  <span class="comment">#  darker / pale night / light / ocean / mac / mac light / false 代码主题</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># 复制按钮</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">false</span> <span class="comment"># 是否显示代码语言</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true: 代码块默认不展开 / false: 代码块默认展开 | none: 展开并隐藏折叠按钮</span></span><br><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment"># unit: px</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">true</span> <span class="comment">#代码自动换行，关闭滚动条</span></span><br></pre></td></tr></table></figure><p>同时将站点配置文件<code>_config.yml</code>的<code>highlight</code>设置为<code>false：</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="副标题循环打字效果"><a href="#副标题循环打字效果" class="headerlink" title="副标题循环打字效果"></a>副标题循环打字效果</h3><p>打开配置文件 <code>_config.butterfly.yml：</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (开启打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># loop (循環打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source調用第三方服務</span></span><br><span class="line">  <span class="comment"># source: false 關閉調用</span></span><br><span class="line">  <span class="comment"># source: 1  調用搏天api的隨機語錄（簡體）</span></span><br><span class="line">  <span class="comment"># source: 2  調用一言網的一句話（簡體）</span></span><br><span class="line">  <span class="comment"># source: 3  調用一句網（簡體）</span></span><br><span class="line">  <span class="comment"># source: 4  調用今日詩詞（簡體）</span></span><br><span class="line">  <span class="comment"># subtitle 會先顯示 source , 再顯示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果有英文逗号&#x27; , &#x27;,请使用转义字元 &amp;#44;</span></span><br><span class="line">  <span class="comment"># 如果有英文双引号&#x27; &quot; &#x27;,请使用转义字元 &amp;quot;</span></span><br><span class="line">  <span class="comment"># 开头不允許转义字元，如需要，请把整個句子用双引号包住</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，subtitle只会现示sub的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">你在抱怨什么呢</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">为明天到来的事，说人生像是没有意义</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">没有选择会是唯一的路</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">这不是你自己的问题，人终归要好好去生活</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903183314262.png" alt="image-20250903183314262"></p><h2 id="鼠标样式魔改"><a href="#鼠标样式魔改" class="headerlink" title="鼠标样式魔改"></a>鼠标样式魔改</h2><p>新建文件<code>[BlogRoot]\source\js\cursor.js（默认是没有的）</code>，在里面写上如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">CURSOR</span>;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Math</span>.<span class="property">lerp</span> = <span class="function">(<span class="params">a, b, n</span>) =&gt;</span> (<span class="number">1</span> - n) * a + n * b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyle</span> = (<span class="params">el, attr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">getComputedStyle</span></span><br><span class="line">            ? <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(el)[attr]</span><br><span class="line">            : el.<span class="property">currentStyle</span>[attr];</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cursor</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pos</span> = &#123;<span class="attr">curr</span>: <span class="literal">null</span>, <span class="attr">prev</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pt</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">create</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">init</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">render</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">move</span>(<span class="params">left, top</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">style</span>[<span class="string">&quot;left&quot;</span>] = <span class="string">`<span class="subst">$&#123;left&#125;</span>px`</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">style</span>[<span class="string">&quot;top&quot;</span>] = <span class="string">`<span class="subst">$&#123;top&#125;</span>px`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cursor</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cursor</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">id</span> = <span class="string">&quot;cursor&quot;</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(<span class="variable language_">this</span>.<span class="property">cursor</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; el.<span class="property">length</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">getStyle</span>(el[i], <span class="string">&quot;cursor&quot;</span>) == <span class="string">&quot;pointer&quot;</span>)</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">pt</span>.<span class="title function_">push</span>(el[i].<span class="property">outerHTML</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>((<span class="variable language_">this</span>.<span class="property">scr</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>)));</span><br><span class="line">        <span class="comment">// 这里改变鼠标指针的颜色 由svg生成</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scr</span>.<span class="property">innerHTML</span> = <span class="string">`* &#123;cursor: url(&quot;data:image/svg+xml,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 8 8&#x27; width=&#x27;8px&#x27; height=&#x27;8px&#x27;&gt;&lt;circle cx=&#x27;4&#x27; cy=&#x27;4&#x27; r=&#x27;4&#x27; opacity=&#x27;.5&#x27;/&gt;&lt;/svg&gt;&quot;) 4 4, auto&#125;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">refresh</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scr</span>.<span class="title function_">remove</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hover&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pos</span> = &#123;<span class="attr">curr</span>: <span class="literal">null</span>, <span class="attr">prev</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pt</span> = [];</span><br><span class="line"> </span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">create</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">init</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">render</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">onmouseover</span>  = <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">pt</span>.<span class="title function_">includes</span>(e.<span class="property">target</span>.<span class="property">outerHTML</span>) &amp;&amp; <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hover&quot;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">onmouseout</span>   = <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">pt</span>.<span class="title function_">includes</span>(e.<span class="property">target</span>.<span class="property">outerHTML</span>) &amp;&amp; <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hover&quot;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">onmousemove</span>  = <span class="function"><span class="params">e</span> =&gt;</span> &#123;(<span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">curr</span> == <span class="literal">null</span>) &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">move</span>(e.<span class="property">clientX</span> - <span class="number">8</span>, e.<span class="property">clientY</span> - <span class="number">8</span>); <span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">curr</span> = &#123;<span class="attr">x</span>: e.<span class="property">clientX</span> - <span class="number">8</span>, <span class="attr">y</span>: e.<span class="property">clientY</span> - <span class="number">8</span>&#125;; <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hidden&quot;</span>);&#125;;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">onmouseenter</span> = <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">onmouseleave</span> = <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">onmousedown</span>  = <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">onmouseup</span>    = <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">cursor</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">prev</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">prev</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="title function_">lerp</span>(<span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">prev</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">curr</span>.<span class="property">x</span>, <span class="number">0.15</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">prev</span>.<span class="property">y</span> = <span class="title class_">Math</span>.<span class="title function_">lerp</span>(<span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">prev</span>.<span class="property">y</span>, <span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">curr</span>.<span class="property">y</span>, <span class="number">0.15</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">move</span>(<span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">prev</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">prev</span>.<span class="property">y</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">pos</span>.<span class="property">curr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">render</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable constant_">CURSOR</span> = <span class="keyword">new</span> <span class="title class_">Cursor</span>();</span><br><span class="line">    <span class="comment">// 需要重新获取列表时，使用 CURSOR.refresh()</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>其中比较重要的参数就是鼠标的尺寸和颜色，已经在上面的代码中标出，可以自行调节。</p><p>在<code>[BlogRoot]\source\css\custom.css</code>添加如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 鼠标样式 */</span></span><br><span class="line"><span class="selector-id">#cursor</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="comment">/* 这里改变跟随的底色 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--theme-color);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.25</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10086</span>;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.2s</span> ease-in-out;</span><br><span class="line">  <span class="attribute">transition-property</span>: background, opacity, transform;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-id">#cursor</span><span class="selector-class">.hidden</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-id">#cursor</span><span class="selector-class">.hover</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.1</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2.5</span>);</span><br><span class="line">  -moz-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2.5</span>);</span><br><span class="line">  -ms-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2.5</span>);</span><br><span class="line">  -o-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-id">#cursor</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  -moz-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  -ms-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  -o-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较重要的参数就是鼠标跟随的圆形颜色，可以根据自己的喜好进行更改：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#cursor</span> &#123;</span><br><span class="line">  <span class="comment">/* 这里改变跟随的底色 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">57</span>, <span class="number">197</span>, <span class="number">187</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在主题配置文件 <code>_config.butterfly.yml</code>文件的<code>inject</code>配置项引入刚刚创建的 <code>css </code>文件和 <code>js</code>文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span> </span><br><span class="line">  <span class="attr">head:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/custom.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">defer</span> <span class="string">src=&quot;/js/cursor.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Live2D看板娘"><a href="#Live2D看板娘" class="headerlink" title="Live2D看板娘"></a>Live2D看板娘</h2><p>在Hexo根目录<code>[BlogRoot]</code>下打开终端，输入以下指令安装必要插件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>打开站点配置文件<code>[BlogRoot]\config.yml</code><br>搜索live2d,按照如下注释内容指示进行操作。<br>如果没有搜到live2d的配置项，就直接把以下内容复制到最底部。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#开关插件版看板娘</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://npm.elemecdn.com/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 相对于博客根目录的路径</span></span><br><span class="line">    <span class="comment"># use: https://npm.elemecdn.com/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span> <span class="comment">#控制看板娘位置</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span> <span class="comment">#控制看板娘大小</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span> <span class="comment">#控制看板娘大小</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span> <span class="comment"># 手机中是否展示</span></span><br></pre></td></tr></table></figure><p>我这里使用live2d-widget-model-wanko模型时没有效果，所以又重新安装了另一个模型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save live2d-widget-model-koharu</span><br></pre></td></tr></table></figure><p>然后在站点配置文件<code>[Blogroot]\_config.yml</code>里找到<code>model</code>项修改为期望的模型。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">model:</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">live2d-widget-model-koharu</span></span><br><span class="line">  <span class="comment"># 默认为live2d-widget-model-wanko</span></span><br></pre></td></tr></table></figure><p>完成后保存修改，在Hexo根目录下运行指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>之所以必须要使用hexo clean是因为我们需要清空缓存重新生成静态页面，不然看板娘没被加入生成的静态页面里，是不会出现的。</p><p>效果如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903184052683.png" alt="image-20250903184052683"></p><p><strong>卸载看板娘</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-helper-live2d <span class="comment">#卸载看板娘插件</span></span><br><span class="line">npm uninstall live2d-widget-model-modelname <span class="comment">#卸载看板娘模型。记得替换modelname为看板娘名称</span></span><br></pre></td></tr></table></figure><p>卸载后为了保证配置项不出错，记得把<code>[Blogroot]\_config.yml</code>里的配置项给注释或者删除掉。</p><h2 id="文章置顶滚动栏"><a href="#文章置顶滚动栏" class="headerlink" title="文章置顶滚动栏"></a>文章置顶滚动栏</h2><p>安装插件,在博客根目录<code>[BlogRoot]</code>下打开终端，运行以下指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-butterfly-swiper --save</span><br></pre></td></tr></table></figure><p>在站点配置文件<code>_config.yml</code>或者主题配置文件<code>_config.butterfly.yml</code>中添加：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-butterfly-swiper</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/8e1264d1/</span></span><br><span class="line"><span class="attr">swiper:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面</span></span><br><span class="line">  <span class="attr">timemode:</span> <span class="string">date</span> <span class="comment">#date/updated</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">recent-posts</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">default_descr:</span> <span class="string">再怎么看我也不知道怎么描述它的啦！</span></span><br><span class="line">  <span class="attr">swiper_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css</span> <span class="comment">#swiper css依赖</span></span><br><span class="line">  <span class="attr">swiper_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js</span> <span class="comment">#swiper js依赖</span></span><br><span class="line">  <span class="attr">custom_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css</span> <span class="comment"># 适配主题样式补丁</span></span><br><span class="line">  <span class="attr">custom_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js</span> <span class="comment"># swiper初始化方法</span></span><br></pre></td></tr></table></figure><h2 id="文章分享功能"><a href="#文章分享功能" class="headerlink" title="文章分享功能"></a>文章分享功能</h2><p>打开<code>[Blogroot]\_config.yml</code></p><p><code>addThis</code>、<code>sharejs</code>、<code>addtoany</code>三个选一个开启</p><p>addThis官网：<a href="https://www.addthis.com/">https://www.addthis.com/</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Share System (分享功能)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AddThis</span></span><br><span class="line"><span class="comment"># https://www.addthis.com/</span></span><br><span class="line"><span class="attr">addThis:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">pubid:</span>  <span class="comment">#访问 AddThis 官网, 找到你的 pub-id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share.js</span></span><br><span class="line"><span class="comment"># https://github.com/overtrue/share.js</span></span><br><span class="line"><span class="attr">sharejs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">sites:</span> <span class="string">facebook,twitter,wechat,weibo,qq</span>  <span class="comment">#想要显示的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AddToAny</span></span><br><span class="line"><span class="comment"># https://www.addtoany.com/</span></span><br><span class="line"><span class="attr">addtoany:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">item:</span> <span class="string">facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我这里使用的时默认的sharejs</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">share:</span></span><br><span class="line">  <span class="comment"># Choose: sharejs / addtoany</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need share</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">sharejs</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Share.js</span></span><br><span class="line">  <span class="comment"># https://github.com/overtrue/share.js</span></span><br><span class="line">  <span class="attr">sharejs:</span></span><br><span class="line">    <span class="attr">sites:</span> <span class="string">wechat,weibo,qq</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># AddToAny</span></span><br><span class="line">  <span class="comment"># https://www.addtoany.com/</span></span><br><span class="line">  <span class="attr">addtoany:</span></span><br><span class="line">    <span class="attr">item:</span> <span class="string">facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link</span></span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在本地完成修改后，在根目录进入cmd，依次输入<code>hexo g</code>、<code>hexo deploy</code>就可以重新部署了。</p>]]></content>
    
    
    <summary type="html">个人博客搭建教程</summary>
    
    
    
    <category term="技术" scheme="https://www.ersblog.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="https://www.ersblog.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Butterfly搭建个人博客网站(一、Hexo初步搭建)</title>
    <link href="https://www.ersblog.cn/posts/a937eeb6/"/>
    <id>https://www.ersblog.cn/posts/a937eeb6/</id>
    <published>2025-09-03T07:47:45.000Z</published>
    <updated>2025-10-13T13:24:06.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>准备一个Hexo文件夹，cmd进去。</p><p>1.全局安装<code>hexo-cli</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>2.安装 <code>Hexo</code> 完成后，请执行下列命令，<code>Hexo</code> 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903163317415.png" alt="image-20250903163317415"></p><p>3.跳转到根目录，安装依赖。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>4.最后输入<code>hexo s</code>启动项目。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903163526451.png" alt="image-20250903163526451"></p><p>页面如下：</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/3de143fc3d139b3bbcf2cab5416b80ab.png" alt="img"></p><h2 id="Hexo常用指令"><a href="#Hexo常用指令" class="headerlink" title="Hexo常用指令"></a>Hexo常用指令</h2><p>1.<code>new</code>:新建一篇文章</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;title&quot;</span></span><br></pre></td></tr></table></figure><p>2.<code>generate</code>:</p><p>生成 Hexo 博客的静态文件。运行这个命令后，Hexo 会根据你的 Markdown 文件生成对应的 HTML 文件，这些文件会被保存在 <code>public</code> 目录下。你可以通过浏览器访问这个目录下的文件，查看你的博客页面。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate </span><br><span class="line">//可以简写</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>3.<code>server</code>:启动服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">//可以简写</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>4.<code>deploy</code>:部署项目</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>5.<code>clean</code>:</p><p>清理 Hexo 生成的缓存和已生成的静态文件。通常在你修改了配置或主题后运行此命令，确保生成的文件是最新的。</p><p>它会删除 <code>public</code> 目录中的所有文件和 <code>_posts</code> 目录中的缓存文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h2 id="快速部署到GitHub服务器"><a href="#快速部署到GitHub服务器" class="headerlink" title="快速部署到GitHub服务器"></a>快速部署到GitHub服务器</h2><h3 id="GitHubPages"><a href="#GitHubPages" class="headerlink" title="GitHubPages"></a>GitHubPages</h3><p><code>GitHub Pages</code> 是 <code>GitHub</code> 上一项免费的托管服务，它可以让用户将静态网页文件、图片、视频和其他媒体文件托管在 <code>GitHub</code> 上，而无需购买虚拟主机或服务器空间。</p><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>命名规则：username.github.io(username为你的用户名)。</p><p>创建完仓库后，找到该仓库的http地址，然后复制下来。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903164655652.png" alt="image-20250903164655652"></p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>回到根目录，进入cmd。</p><p>首先安装hexo-deployer-git.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>第二步在根目录下的<code>_config.yml</code>文件中添加配置。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/megumieren/megumieren.github.io.git</span> <span class="string">//刚刚复制的http地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>第三步生成静态文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g 或者 hexo generate</span><br></pre></td></tr></table></figure><p>最后一步部署。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d 或者 hexo deploy</span><br></pre></td></tr></table></figure><p>部署完成后，进入Github仓库页面，点击右上角Settings，然后点击Pages，Deploy from a branch选择master，最后点击save即可。</p><p><img src="https://ersblog-1344614417.cos.ap-nanjing.myqcloud.com/img/image-20250903165625530.png" alt="image-20250903165625530"></p><p>接着就可以访问username.github.io进入你的在线网站了。</p>]]></content>
    
    
    <summary type="html">个人博客搭建教程</summary>
    
    
    
    <category term="技术" scheme="https://www.ersblog.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="https://www.ersblog.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
